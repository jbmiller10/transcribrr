target_file: "app/ThreadManager.py"
test_file: "app/tests/test_thread_manager.py"
dependencies_to_mock:
  - "logging.getLogger"
  - "PyQt6.QtCore.QThread"
  - "weakref.ref"

test_cases:
  # Singleton Pattern Tests
  - function_to_test: "ThreadManager.instance"
    description: "Tests singleton creation on first call"
    scenario: "When instance() is called for the first time, it should create and return a new ThreadManager instance"
    mocks: []
    expected_behavior:
      - "A new ThreadManager instance is created"
      - "The _instance class variable is set to the new instance"
      - "The same instance is returned"
      - "Logger debug message indicates initialization"

  - function_to_test: "ThreadManager.instance"
    description: "Tests singleton returns same instance on subsequent calls"
    scenario: "When instance() is called multiple times, it should return the same ThreadManager instance"
    mocks: []
    expected_behavior:
      - "The same instance is returned for all calls"
      - "_instance is not recreated"
      - "No additional initialization logging occurs"

  # Thread Registration Tests
  - function_to_test: "ThreadManager.register_thread"
    description: "Tests successful thread registration"
    scenario: "When registering a new thread that hasn't been registered before"
    mocks:
      - target: "QThread"
        return_value: "mock thread object with id, __class__.__name__, and finished signal"
      - target: "weakref.ref"
        return_value: "weak reference to thread"
    expected_behavior:
      - "Thread is added to _active_threads dictionary with id as key"
      - "Debug log message confirms registration with thread class name and id"
      - "Thread's finished signal is connected to auto-unregister callback"
      - "Weak reference is created for the thread"

  - function_to_test: "ThreadManager.register_thread"
    description: "Tests duplicate thread registration handling"
    scenario: "When attempting to register a thread that's already registered"
    mocks:
      - target: "QThread"
        return_value: "mock thread object with same id as existing thread"
    expected_behavior:
      - "Warning log message about thread already being registered"
      - "Thread is not added again to _active_threads"
      - "Method returns early without connecting signals"
      - "No weak reference is created"

  - function_to_test: "ThreadManager.register_thread"
    description: "Tests automatic unregistration callback setup"
    scenario: "When thread finishes, the connected callback should unregister it"
    mocks:
      - target: "QThread"
        return_value: "mock thread with finished signal"
      - target: "weakref.ref"
        return_value: "weak reference that returns the thread object"
    expected_behavior:
      - "Callback function is created with weak reference"
      - "When callback is invoked (simulating thread.finished), unregister_thread is called"
      - "Thread is removed from _active_threads"
      - "Weak reference prevents thread from being kept alive"

  - function_to_test: "ThreadManager.register_thread"
    description: "Tests weak reference cleanup when thread is garbage collected"
    scenario: "When thread is garbage collected before finished signal, weak reference returns None"
    mocks:
      - target: "weakref.ref"
        return_value: "weak reference that returns None (thread garbage collected)"
    expected_behavior:
      - "Callback function handles None gracefully"
      - "unregister_thread is not called when weak_ref returns None"
      - "No exceptions are raised"

  # Thread Unregistration Tests
  - function_to_test: "ThreadManager.unregister_thread"
    description: "Tests successful thread unregistration"
    scenario: "When unregistering a thread that is currently registered"
    mocks:
      - target: "QThread"
        return_value: "mock thread object with id and __class__.__name__"
    expected_behavior:
      - "Thread is removed from _active_threads dictionary"
      - "Debug log message confirms unregistration with thread class name and id"
      - "No exceptions are raised"

  - function_to_test: "ThreadManager.unregister_thread"
    description: "Tests unregistering non-registered thread"
    scenario: "When attempting to unregister a thread that's not in _active_threads"
    mocks:
      - target: "QThread"
        return_value: "mock thread object not in registry"
    expected_behavior:
      - "Debug log message about attempting to unregister non-registered thread"
      - "No exceptions are raised"
      - "_active_threads dictionary remains unchanged"

  # Active Threads Retrieval Tests
  - function_to_test: "ThreadManager.get_active_threads"
    description: "Tests retrieving list of active threads"
    scenario: "When there are multiple threads registered"
    mocks:
      - target: "QThread"
        return_value: "multiple mock thread objects"
    expected_behavior:
      - "Returns a list containing all registered thread objects"
      - "List is a copy, not reference to internal dictionary values"
      - "Order of threads in list matches insertion order"

  - function_to_test: "ThreadManager.get_active_threads"
    description: "Tests retrieving empty list when no threads"
    scenario: "When no threads are registered"
    mocks: []
    expected_behavior:
      - "Returns an empty list"
      - "No exceptions are raised"

  # Thread Cancellation Tests
  - function_to_test: "ThreadManager.cancel_all_threads"
    description: "Tests cancelling all threads with cancel method"
    scenario: "When all registered threads have a cancel() method and are running"
    mocks:
      - target: "QThread"
        return_value: "mock threads with cancel() method, isRunning() returns True, wait() returns True"
    expected_behavior:
      - "Info log about cancelling N active threads"
      - "cancel() is called on each thread"
      - "Debug logs for each cancellation attempt"
      - "wait() is called with timeout for each running thread"
      - "Debug logs confirm successful thread completion"

  - function_to_test: "ThreadManager.cancel_all_threads"
    description: "Tests handling threads without cancel method"
    scenario: "When some threads don't have a cancel() method"
    mocks:
      - target: "QThread"
        return_value: "mock threads without cancel() method"
    expected_behavior:
      - "Warning log for threads without cancel() method"
      - "No exception raised for missing cancel() method"
      - "wait() is still called if thread is running"
      - "Processing continues for remaining threads"

  - function_to_test: "ThreadManager.cancel_all_threads"
    description: "Tests cancel method exception handling"
    scenario: "When thread.cancel() raises an exception"
    mocks:
      - target: "QThread.cancel"
        side_effect: "raises RuntimeError"
    expected_behavior:
      - "Exception is caught and logged as error"
      - "Error message includes thread name and exception details"
      - "Processing continues for remaining threads"
      - "wait() is still attempted if thread is running"

  - function_to_test: "ThreadManager.cancel_all_threads"
    description: "Tests thread timeout during cancellation"
    scenario: "When threads don't finish within the specified timeout"
    mocks:
      - target: "QThread"
        return_value: "mock thread where isRunning() returns True, wait() returns False"
    expected_behavior:
      - "wait() is called with specified timeout (default 5000ms)"
      - "Warning log when thread doesn't finish within timeout"
      - "Comment indicates thread will be forcefully terminated by cleanup_application"
      - "Processing continues for remaining threads"

  - function_to_test: "ThreadManager.cancel_all_threads"
    description: "Tests custom timeout parameter"
    scenario: "When a custom wait_timeout is provided"
    mocks:
      - target: "QThread"
        return_value: "mock running thread"
    expected_behavior:
      - "wait() is called with the custom timeout value"
      - "Debug log shows the custom timeout value"
      - "Timeout behavior follows custom value"

  - function_to_test: "ThreadManager.cancel_all_threads"
    description: "Tests with no active threads"
    scenario: "When there are no threads registered"
    mocks: []
    expected_behavior:
      - "Debug log message 'No active threads to cancel'"
      - "Method returns early"
      - "No further processing occurs"

  - function_to_test: "ThreadManager.cancel_all_threads"
    description: "Tests with threads that are not running"
    scenario: "When registered threads exist but isRunning() returns False"
    mocks:
      - target: "QThread"
        return_value: "mock thread where isRunning() returns False"
    expected_behavior:
      - "cancel() is still called if method exists"
      - "wait() is not called since thread is not running"
      - "No timeout warnings are logged"

  # Thread Lifecycle Integration Tests
  - function_to_test: "ThreadManager (integration)"
    description: "Tests complete thread lifecycle from registration to auto-unregistration"
    scenario: "Thread is registered, runs, finishes, and is automatically unregistered"
    mocks:
      - target: "QThread"
        return_value: "mock thread with full signal support"
      - target: "weakref.ref"
        return_value: "functioning weak reference"
    expected_behavior:
      - "Thread is registered successfully"
      - "Thread appears in get_active_threads()"
      - "When finished signal is emitted, auto-unregister callback is triggered"
      - "Thread is removed from active threads"
      - "Thread no longer appears in get_active_threads()"

  - function_to_test: "ThreadManager (concurrency)"
    description: "Tests thread-safe operations with concurrent registrations"
    scenario: "Multiple threads are registered and unregistered concurrently"
    mocks:
      - target: "QThread"
        return_value: "multiple mock threads with unique ids"
    expected_behavior:
      - "All threads are registered without conflicts"
      - "Each thread has unique id in _active_threads"
      - "Concurrent unregistrations don't cause key errors"
      - "Final state reflects all operations correctly"

  - function_to_test: "ThreadManager.__init__"
    description: "Tests initialization of ThreadManager instance"
    scenario: "When ThreadManager is instantiated directly (not through instance())"
    mocks:
      - target: "logging.getLogger"
        return_value: "mock logger"
    expected_behavior:
      - "_active_threads is initialized as empty dictionary"
      - "Debug log message 'ThreadManager initialized'"
      - "Instance is properly initialized for use"