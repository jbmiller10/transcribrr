target_file: "app/models/recording.py"
test_file: "app/tests/test_recording_model.py"
dependencies_to_mock: []  # No external dependencies in the dataclass itself

test_cases:
  # Basic initialization and attribute access tests
  - function_to_test: "Recording.__init__"
    description: "Tests successful initialization with all required fields"
    scenario: "Creating a Recording instance with all required fields provided"
    mocks: []
    expected_behavior:
      - "Recording instance is created successfully"
      - "All required attributes are set correctly (id, filename, file_path, date_created, duration)"
      - "Optional fields default to None"
      - "All attributes are accessible via dot notation"

  - function_to_test: "Recording.__init__"
    description: "Tests initialization with all fields including optional ones"
    scenario: "Creating a Recording instance with all fields (required and optional) provided"
    mocks: []
    expected_behavior:
      - "Recording instance is created with all attributes set"
      - "Optional fields contain the provided values"
      - "No attributes are None when all fields are provided"

  # Type validation tests
  - function_to_test: "Recording.__init__"
    description: "Tests type validation for integer id field"
    scenario: "Attempting to create Recording with non-integer id"
    mocks: []
    expected_behavior:
      - "Recording accepts the value (dataclass does not enforce runtime type checking)"
      - "Type checkers should flag this as an error during static analysis"

  - function_to_test: "Recording.__init__"
    description: "Tests type validation for float duration field"
    scenario: "Creating Recording with integer duration (should be coerced to float)"
    mocks: []
    expected_behavior:
      - "Integer duration is accepted and works as float"
      - "No runtime errors occur"

  - function_to_test: "Recording.__init__"
    description: "Tests string fields with empty strings"
    scenario: "Creating Recording with empty strings for filename, file_path, and date_created"
    mocks: []
    expected_behavior:
      - "Recording is created successfully with empty strings"
      - "Empty strings are stored as-is (no validation in dataclass)"

  # Edge cases and boundary conditions
  - function_to_test: "Recording.__init__"
    description: "Tests initialization with None for optional fields"
    scenario: "Explicitly setting optional fields to None"
    mocks: []
    expected_behavior:
      - "Recording accepts None for all optional fields"
      - "No errors or warnings are raised"

  - function_to_test: "Recording.__init__"
    description: "Tests initialization with very long strings"
    scenario: "Creating Recording with extremely long strings for text fields"
    mocks: []
    expected_behavior:
      - "Recording stores long strings without truncation"
      - "No memory errors for reasonable string lengths"

  - function_to_test: "Recording.__init__"
    description: "Tests initialization with negative duration"
    scenario: "Creating Recording with negative duration value"
    mocks: []
    expected_behavior:
      - "Negative duration is accepted (no validation in dataclass)"
      - "Value is stored as provided"

  - function_to_test: "Recording.__init__"
    description: "Tests initialization with zero duration"
    scenario: "Creating Recording with duration of 0.0"
    mocks: []
    expected_behavior:
      - "Zero duration is accepted"
      - "Value is stored as 0.0"

  # Dataclass-specific functionality tests
  - function_to_test: "Recording.__eq__"
    description: "Tests equality comparison between Recording instances"
    scenario: "Comparing two Recording instances with identical values"
    mocks: []
    expected_behavior:
      - "Two instances with same values are equal"
      - "Equality uses all fields for comparison"

  - function_to_test: "Recording.__eq__"
    description: "Tests inequality comparison between Recording instances"
    scenario: "Comparing two Recording instances with different values"
    mocks: []
    expected_behavior:
      - "Two instances with different values are not equal"
      - "Changing any single field makes instances unequal"

  - function_to_test: "Recording.__repr__"
    description: "Tests string representation of Recording instance"
    scenario: "Getting repr() of a Recording instance"
    mocks: []
    expected_behavior:
      - "repr() returns a string containing class name and all field values"
      - "String can be used to recreate the object (eval-able)"

  - function_to_test: "Recording.__hash__"
    description: "Tests hashability of Recording instances"
    scenario: "Attempting to use Recording instance as dictionary key or in set"
    mocks: []
    expected_behavior:
      - "Recording instances are not hashable by default (dataclass with mutable fields)"
      - "TypeError is raised when trying to hash"

  # Field mutation tests
  - function_to_test: "Recording attribute mutation"
    description: "Tests mutability of Recording fields"
    scenario: "Modifying attributes after initialization"
    mocks: []
    expected_behavior:
      - "All fields can be modified after initialization"
      - "Changes persist in the instance"
      - "No frozen dataclass errors"

  # Special date handling scenarios (based on db_utils.py usage)
  - function_to_test: "Recording with date_created edge cases"
    description: "Tests Recording with various date_created formats"
    scenario: "Creating Recording with date_created as 'pending', 'None', or empty string (as seen in db_utils)"
    mocks: []
    expected_behavior:
      - "Recording accepts any string value for date_created"
      - "Special values like 'pending' are stored as-is"
      - "No date validation or parsing occurs in the model"

  # Field access patterns
  - function_to_test: "Recording field access"
    description: "Tests accessing all fields via dot notation"
    scenario: "Accessing each field of a fully populated Recording instance"
    mocks: []
    expected_behavior:
      - "All fields are accessible via dot notation"
      - "No AttributeError for defined fields"
      - "Fields return exact values that were set"

  - function_to_test: "Recording undefined attribute access"
    description: "Tests accessing undefined attributes"
    scenario: "Attempting to access an attribute that doesn't exist on Recording"
    mocks: []
    expected_behavior:
      - "AttributeError is raised for undefined attributes"
      - "Error message indicates the attribute name"

  # Integration scenarios based on actual usage
  - function_to_test: "Recording creation from database tuple"
    description: "Tests creating Recording from database query result"
    scenario: "Simulating the pattern used in db_utils.get_recording_by_id"
    mocks: []
    expected_behavior:
      - "Recording can be created from positional arguments matching database columns"
      - "Missing optional fields can be handled with conditional logic"
      - "Tuple unpacking works correctly"

  - function_to_test: "Recording creation from dictionary"
    description: "Tests creating Recording from dictionary (as in MainTranscriptionWidget)"
    scenario: "Creating Recording using dictionary key access pattern"
    mocks: []
    expected_behavior:
      - "Recording can be created by passing dictionary values as arguments"
      - "Dictionary keys map correctly to Recording fields"

  # Memory and performance considerations
  - function_to_test: "Recording with large transcript data"
    description: "Tests Recording with very large transcript strings"
    scenario: "Creating Recording with multi-megabyte transcript strings"
    mocks: []
    expected_behavior:
      - "Large strings are stored without issues"
      - "Memory usage is proportional to data size"
      - "No artificial limits on string sizes"

  # Dataclass features verification
  - function_to_test: "Recording field order"
    description: "Tests that field order is preserved as defined"
    scenario: "Verifying the order of fields in the dataclass"
    mocks: []
    expected_behavior:
      - "Fields maintain definition order"
      - "__dataclass_fields__ preserves order"
      - "Required fields come before optional fields"

  - function_to_test: "Recording.__init__ signature"
    description: "Tests the generated __init__ method signature"
    scenario: "Inspecting the __init__ method parameters"
    mocks: []
    expected_behavior:
      - "__init__ has parameters for all fields"
      - "Optional fields have None as default"
      - "Required fields have no defaults"

  # Copy and modification patterns
  - function_to_test: "Recording copy operations"
    description: "Tests creating copies of Recording instances"
    scenario: "Using copy module or manual field copying"
    mocks: []
    expected_behavior:
      - "Shallow copy creates new instance with same values"
      - "Modifying copy doesn't affect original"
      - "Deep copy handles nested data correctly"

  # Serialization readiness
  - function_to_test: "Recording dict conversion"
    description: "Tests converting Recording to dictionary"
    scenario: "Using dataclasses.asdict() or manual conversion"
    mocks: []
    expected_behavior:
      - "All fields are included in dictionary"
      - "None values are preserved for optional fields"
      - "Dictionary keys match field names"

  - function_to_test: "Recording tuple conversion"
    description: "Tests converting Recording to tuple"
    scenario: "Using dataclasses.astuple() for database operations"
    mocks: []
    expected_behavior:
      - "Fields are converted to tuple in definition order"
      - "None values are preserved"
      - "Tuple can be used for database inserts"