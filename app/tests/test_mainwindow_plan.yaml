target_file: "app/MainWindow.py"
test_file: "app/tests/test_mainwindow.py"
dependencies_to_mock:
  - "app.MainTranscriptionWidget.MainTranscriptionWidget"
  - "app.ControlPanelWidget.ControlPanelWidget"
  - "app.DatabaseManager.DatabaseManager"
  - "app.FolderManager.FolderManager"
  - "app.RecentRecordingsWidget.RecentRecordingsWidget"
  - "app.file_utils.calculate_duration"
  - "PyQt6.QtWidgets.QApplication"
  - "PyQt6.QtWidgets.QMessageBox"
  - "PyQt6.QtWidgets.QStatusBar"
  - "PyQt6.QtCore.QTimer"
  - "os.path.basename"
  - "datetime.datetime.now"
  - "sys.exit"
  - "logging.getLogger"

test_cases:
  - function_to_test: "MainWindow.__init__"
    description: "Tests successful initialization with all components created properly"
    scenario: "When MainWindow is initialized with all dependencies working correctly"
    mocks:
      - target: "DatabaseManager"
        return_value: "Mock DatabaseManager instance"
      - target: "FolderManager.instance"
        return_value: "Mock FolderManager singleton"
      - target: "QMessageBox.critical"
        return_value: "None (not called)"
      - target: "sys.exit"
        return_value: "None (not called)"
    expected_behavior:
      - "DatabaseManager is instantiated with self as parent"
      - "FolderManager.instance() is called with db_manager parameter"
      - "init_ui() method is called"
      - "No critical error messages are shown"
      - "Application does not exit"
      - "Logger records successful initialization messages"

  - function_to_test: "MainWindow.__init__"
    description: "Tests handling of DatabaseManager initialization failure"
    scenario: "When DatabaseManager raises an exception during initialization"
    mocks:
      - target: "DatabaseManager"
        side_effect: "raises RuntimeError('Database connection failed')"
      - target: "QMessageBox.critical"
        return_value: "None"
      - target: "sys.exit"
        return_value: "None"
      - target: "logger.critical"
        return_value: "None"
    expected_behavior:
      - "QMessageBox.critical is called with error message containing 'Database Manager'"
      - "Logger critical method is called with exception details"
      - "sys.exit(1) is called to terminate application"
      - "FolderManager is not initialized"
      - "init_ui is not called"

  - function_to_test: "MainWindow.__init__"
    description: "Tests handling of FolderManager initialization failure"
    scenario: "When FolderManager.instance() raises a RuntimeError"
    mocks:
      - target: "DatabaseManager"
        return_value: "Mock DatabaseManager instance"
      - target: "FolderManager.instance"
        side_effect: "raises RuntimeError('FolderManager already initialized')"
      - target: "QMessageBox.critical"
        return_value: "None"
      - target: "sys.exit"
        return_value: "None"
      - target: "logger.critical"
        return_value: "None"
    expected_behavior:
      - "DatabaseManager is successfully created"
      - "QMessageBox.critical is called with error message containing 'Folder Manager'"
      - "Logger critical method is called with RuntimeError details"
      - "sys.exit(1) is called to terminate application"
      - "init_ui is not called"

  - function_to_test: "MainWindow.__init__"
    description: "Tests handling of unexpected FolderManager exception"
    scenario: "When FolderManager.instance() raises an unexpected exception"
    mocks:
      - target: "DatabaseManager"
        return_value: "Mock DatabaseManager instance"
      - target: "FolderManager.instance"
        side_effect: "raises ValueError('Invalid configuration')"
      - target: "QMessageBox.critical"
        return_value: "None"
      - target: "sys.exit"
        return_value: "None"
      - target: "logger.critical"
        return_value: "None"
    expected_behavior:
      - "DatabaseManager is successfully created"
      - "QMessageBox.critical is called with 'Unexpected error during Folder Manager setup'"
      - "Logger critical method is called with unexpected exception details"
      - "sys.exit(1) is called to terminate application"
      - "init_ui is not called"

  - function_to_test: "MainWindow.__init__"
    description: "Tests handling of UI initialization failure"
    scenario: "When init_ui() raises an exception during UI setup"
    mocks:
      - target: "DatabaseManager"
        return_value: "Mock DatabaseManager instance"
      - target: "FolderManager.instance"
        return_value: "Mock FolderManager singleton"
      - target: "MainWindow.init_ui"
        side_effect: "raises Exception('Widget creation failed')"
      - target: "QMessageBox.critical"
        return_value: "None"
      - target: "sys.exit"
        return_value: "None"
      - target: "logger.critical"
        return_value: "None"
    expected_behavior:
      - "DatabaseManager and FolderManager are successfully initialized"
      - "QMessageBox.critical is called with error message containing 'UI setup'"
      - "Logger critical method is called with UI initialization exception"
      - "sys.exit(1) is called to terminate application"

  - function_to_test: "MainWindow.init_ui"
    description: "Tests successful UI initialization with all widgets and connections"
    scenario: "When all UI components are created and connected successfully"
    mocks:
      - target: "QApplication.primaryScreen"
        return_value: "Mock screen with availableGeometry"
      - target: "ControlPanelWidget"
        return_value: "Mock control panel with file_ready_for_processing signal"
      - target: "RecentRecordingsWidget"
        return_value: "Mock recent recordings widget with signals"
      - target: "MainTranscriptionWidget"
        return_value: "Mock transcription widget with signals"
      - target: "QStatusBar"
        return_value: "Mock status bar"
    expected_behavior:
      - "Window title is set to APP_NAME constant"
      - "Window is resized to 80% of screen size (max 1690x960)"
      - "Window is centered on screen"
      - "All three main widgets are created with correct parameters"
      - "Splitter is configured with correct sizes (30% left, 70% right)"
      - "Status bar is created and shows 'Ready' message"
      - "All signal connections are established"
      - "Recent recordings are loaded via load_recordings()"

  - function_to_test: "MainWindow.init_ui"
    description: "Tests signal connections between widgets"
    scenario: "When init_ui sets up inter-widget communication"
    mocks:
      - target: "ControlPanelWidget"
        return_value: "Mock with file_ready_for_processing signal"
      - target: "RecentRecordingsWidget"
        return_value: "Mock with recordingItemSelected signal"
      - target: "MainTranscriptionWidget"
        return_value: "Mock with recording_status_updated and status_update signals"
    expected_behavior:
      - "control_panel.file_ready_for_processing connects to on_new_file"
      - "recent_recordings.recordingItemSelected connects to transcription.on_recording_item_selected"
      - "transcription.recording_status_updated connects to recent_recordings.update_recording_status"
      - "transcription.status_update connects to update_status_bar"

  - function_to_test: "MainWindow.on_new_file"
    description: "Tests successful processing of a new audio file"
    scenario: "When a new audio file is ready for processing with valid path"
    mocks:
      - target: "os.path.basename"
        return_value: "audio_file.mp3"
      - target: "datetime.datetime.now"
        return_value: "Mock datetime with strftime returning '2024-01-15 10:30:00'"
      - target: "calculate_duration"
        return_value: "00:05:30"
      - target: "db_manager.create_recording"
        return_value: "Calls callback with recording_id=123"
      - target: "QTimer.singleShot"
        return_value: "Executes callback immediately"
      - target: "recent_recordings_widget.add_recording_to_list"
        return_value: "None"
      - target: "unified_view.select_item_by_id"
        return_value: "None"
    expected_behavior:
      - "File basename is extracted from path"
      - "Current datetime is formatted as string"
      - "Duration is calculated for the audio file"
      - "Recording data tuple is created with all 7 fields"
      - "Database create_recording is called with data and callback"
      - "On success, recording is added to recent recordings list"
      - "New recording is automatically selected after 100ms delay"
      - "Status bar shows 'Added new recording: filename'"
      - "Error handler is disconnected after 5 seconds"

  - function_to_test: "MainWindow.on_new_file"
    description: "Tests database error handling during file processing"
    scenario: "When database create_recording operation fails"
    mocks:
      - target: "os.path.basename"
        return_value: "audio_file.mp3"
      - target: "calculate_duration"
        return_value: "00:05:30"
      - target: "db_manager.error_occurred"
        return_value: "Signal that emits ('create_recording', 'Duplicate entry')"
      - target: "logger.error"
        return_value: "None"
    expected_behavior:
      - "Error handler is connected to db_manager.error_occurred signal"
      - "On error, formatted error message is logged"
      - "Status bar shows error message with filename"
      - "Error handler is disconnected after receiving error"
      - "Recording is not added to the list"

  - function_to_test: "MainWindow.on_new_file"
    description: "Tests exception handling during file processing"
    scenario: "When calculate_duration raises an exception"
    mocks:
      - target: "os.path.basename"
        return_value: "corrupted_file.mp3"
      - target: "calculate_duration"
        side_effect: "raises ValueError('Invalid audio file')"
      - target: "logger.error"
        return_value: "None"
    expected_behavior:
      - "Exception is caught and logged with full traceback"
      - "Status bar shows 'Error processing file: Invalid audio file'"
      - "Database operation is not attempted"
      - "Application continues running without crashing"

  - function_to_test: "MainWindow.update_status_bar"
    description: "Tests status bar message update"
    scenario: "When a status message needs to be displayed"
    mocks:
      - target: "statusBar"
        return_value: "Mock status bar with showMessage method"
      - target: "logger.debug"
        return_value: "None"
    expected_behavior:
      - "statusBar().showMessage() is called with the message"
      - "Logger debug is called with 'Status bar updated: message'"

  - function_to_test: "MainWindow.set_style"
    description: "Tests deprecated style method (no-op)"
    scenario: "When set_style is called (legacy compatibility)"
    mocks: []
    expected_behavior:
      - "Method executes without error"
      - "No operations are performed (pass statement only)"
      - "Styling is handled by ThemeManager instead"

  - function_to_test: "MainWindow.on_new_file"
    description: "Tests unique connection type for error handler"
    scenario: "When connecting error handler with UniqueConnection to prevent duplicates"
    mocks:
      - target: "os.path.basename"
        return_value: "test.mp3"
      - target: "calculate_duration"
        return_value: "00:03:00"
      - target: "db_manager.error_occurred.connect"
        return_value: "None"
    expected_behavior:
      - "error_occurred.connect is called with Qt.ConnectionType.UniqueConnection"
      - "Prevents duplicate connections if method is called multiple times"
      - "Error handler can be safely disconnected even if not connected"

  - function_to_test: "MainWindow.on_new_file"
    description: "Tests automatic error handler cleanup timeout"
    scenario: "When no error occurs within 5 seconds of adding a file"
    mocks:
      - target: "os.path.basename"
        return_value: "success.mp3"
      - target: "calculate_duration"
        return_value: "00:04:00"
      - target: "QTimer.singleShot"
        return_value: "Schedules disconnect_error_handler after 5000ms"
      - target: "db_manager.error_occurred.disconnect"
        return_value: "None or raises TypeError if already disconnected"
    expected_behavior:
      - "QTimer.singleShot(5000, disconnect_error_handler) is called"
      - "Disconnect handler gracefully handles TypeError if already disconnected"
      - "Logger debug message confirms disconnection for the filename"
      - "Prevents memory leaks from lingering signal connections"