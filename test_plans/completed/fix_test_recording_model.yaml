target_file: "app/models/recording.py"
test_file: "app/tests/test_recording_model.py"
dependencies_to_mock:
  - "datetime.datetime.utcnow"
  - "datetime.datetime.strptime"

test_cases:
  # Edge Cases and Boundary Conditions for Validation Methods
  - function_to_test: "Recording.validate_duration"
    description: "Tests duration validation with zero boundary"
    scenario: "When duration is exactly zero (boundary condition)"
    mocks: []
    expected_behavior:
      - "No exception is raised for duration of 0.0"
      - "Method completes successfully"

  - function_to_test: "Recording.validate_duration"
    description: "Tests duration validation with negative infinity"
    scenario: "When duration is negative infinity (extreme edge case)"
    mocks: []
    expected_behavior:
      - "ValueError is raised with message containing 'Duration must be non-negative'"
      - "Exception is raised before any processing"

  - function_to_test: "Recording.validate_duration"
    description: "Tests duration validation with positive infinity"
    scenario: "When duration is positive infinity (extreme edge case)"
    mocks: []
    expected_behavior:
      - "No exception is raised for float('inf')"
      - "Method accepts extreme positive values"

  - function_to_test: "Recording.validate_duration"
    description: "Tests duration validation with NaN"
    scenario: "When duration is NaN (Not a Number)"
    mocks: []
    expected_behavior:
      - "No exception raised (NaN > 0 is False, NaN < 0 is also False)"
      - "Method handles NaN without crashing"

  - function_to_test: "Recording.validate_filename"
    description: "Tests filename validation with whitespace-only string"
    scenario: "When filename contains only spaces, tabs, and newlines"
    mocks: []
    expected_behavior:
      - "ValueError is raised with message 'Filename cannot be empty'"
      - "Whitespace-only strings are treated as empty"

  - function_to_test: "Recording.validate_filename"
    description: "Tests filename validation with Unicode characters"
    scenario: "When filename contains emojis, Chinese characters, RTL text"
    mocks: []
    expected_behavior:
      - "No exception for valid Unicode filenames like 'éŸ³æ¥½.mp3' or 'ðŸŽµrecording.wav'"
      - "Method accepts international character sets"

  - function_to_test: "Recording.validate_filename"
    description: "Tests filename validation with control characters"
    scenario: "When filename contains null bytes or other control characters"
    mocks: []
    expected_behavior:
      - "No exception raised if strip() leaves valid characters"
      - "Only raises ValueError if stripped result is empty"

  - function_to_test: "Recording.validate_file_path"
    description: "Tests path validation with directory traversal attempts"
    scenario: "Various path traversal patterns like '../../../etc/passwd', '..\\..\\windows\\system32'"
    mocks: []
    expected_behavior:
      - "ValueError raised with message 'Invalid file path'"
      - "Both Unix and Windows path separators are checked"
      - "Rejects any path containing '..' component"

  - function_to_test: "Recording.validate_file_path"
    description: "Tests path validation with encoded traversal attempts"
    scenario: "When path contains URL-encoded or obfuscated traversal like '.%2e/', '..;/', '.../'"
    mocks: []
    expected_behavior:
      - "Path with literal '...' (three dots) is accepted"
      - "URL-encoded patterns are not decoded (treated literally)"
      - "Only explicit '..' components are rejected"

  - function_to_test: "Recording.validate_file_path"
    description: "Tests path validation with extremely long paths"
    scenario: "When path exceeds typical OS limits (260 chars on Windows, 4096 on Linux)"
    mocks: []
    expected_behavior:
      - "No exception raised for long paths without '..'"
      - "Validation only checks traversal, not OS limits"

  - function_to_test: "Recording.validate_file_path"
    description: "Tests path validation with special OS filenames"
    scenario: "Windows reserved names like 'CON', 'PRN', 'AUX', 'NUL', 'COM1'"
    mocks: []
    expected_behavior:
      - "No exception raised for Windows reserved names"
      - "Validation only prevents directory traversal"

  - function_to_test: "Recording.validate_date_format"
    description: "Tests date validation with ambiguous formats"
    scenario: "Dates like '2024-13-01' (invalid month), '2024-02-30' (invalid day)"
    mocks:
      - target: "datetime.strptime"
        side_effect: "raises ValueError for invalid dates"
    expected_behavior:
      - "ValueError raised with message 'Invalid date format'"
      - "Strict date validation rejects impossible dates"

  - function_to_test: "Recording.validate_date_format"
    description: "Tests date validation with timezone information"
    scenario: "ISO8601 dates with timezone like '2024-01-15T10:30:00Z' or '2024-01-15+05:30'"
    mocks:
      - target: "datetime.strptime"
        side_effect: "raises ValueError for unsupported format"
    expected_behavior:
      - "ValueError raised with message 'Invalid date format'"
      - "Only accepts YYYY-MM-DD or YYYY-MM-DD HH:MM:SS formats"

  - function_to_test: "Recording.validate_date_format"
    description: "Tests date validation with edge dates"
    scenario: "Extreme dates like '9999-12-31 23:59:59', '0001-01-01 00:00:00'"
    mocks:
      - target: "datetime.strptime"
        return_value: "datetime object for valid extreme dates"
    expected_behavior:
      - "No exception for dates within datetime range"
      - "Accepts any valid date that datetime can parse"

  # Edge Cases for Helper Methods
  - function_to_test: "_format_seconds"
    description: "Tests duration formatting with negative values"
    scenario: "When duration is negative (error condition that shouldn't happen)"
    mocks: []
    expected_behavior:
      - "Returns '0:00' for negative values"
      - "Defensive programming prevents negative display"

  - function_to_test: "_format_seconds"
    description: "Tests duration formatting with fractional seconds"
    scenario: "Durations like 59.999, 3600.5, 0.1"
    mocks: []
    expected_behavior:
      - "59.999 seconds formats as '0:59' (truncation)"
      - "3600.5 seconds formats as '1:00:00'"
      - "0.1 seconds formats as '0:00'"

  - function_to_test: "_format_seconds"
    description: "Tests duration formatting at time boundaries"
    scenario: "Exact boundaries like 60, 3600, 86400 seconds"
    mocks: []
    expected_behavior:
      - "60 seconds formats as '1:00'"
      - "3600 seconds formats as '1:00:00'"
      - "86400 seconds formats as '24:00:00'"

  - function_to_test: "Recording.get_display_duration"
    description: "Tests duration display with extreme values"
    scenario: "Recording with duration of float('inf') or very large number"
    mocks: []
    expected_behavior:
      - "OverflowError or extreme output for infinity"
      - "Very large durations still format correctly"

  - function_to_test: "Recording.estimate_file_size"
    description: "Tests file size estimation with zero bitrate"
    scenario: "When bitrate_kbps is 0 (edge case)"
    mocks: []
    expected_behavior:
      - "Returns 0 bytes (0 bitrate means no data)"
      - "No division by zero error"

  - function_to_test: "Recording.estimate_file_size"
    description: "Tests file size estimation with extreme bitrates"
    scenario: "Bitrates like 1 kbps (very low) or 100000 kbps (extreme high)"
    mocks: []
    expected_behavior:
      - "1 kbps for 60s returns 7500 bytes"
      - "100000 kbps returns proportionally large size"
      - "Calculation remains mathematically correct"

  - function_to_test: "Recording.estimate_file_size"
    description: "Tests file size estimation with negative duration"
    scenario: "Recording with negative duration (shouldn't happen but defensive)"
    mocks: []
    expected_behavior:
      - "Returns 0 bytes due to max(duration, 0)"
      - "Defensive programming prevents negative file sizes"

  # State Management and Side Effects
  - function_to_test: "Recording.update_transcript"
    description: "Tests transcript update with empty string"
    scenario: "Updating transcript with empty string (edge case)"
    mocks:
      - target: "datetime.utcnow"
        return_value: "datetime(2024, 1, 15, 10, 30, 0)"
    expected_behavior:
      - "raw_transcript is set to empty string"
      - "transcribed_at is still set to current time"
      - "Empty transcript is valid state"

  - function_to_test: "Recording.update_transcript"
    description: "Tests transcript update with very large text"
    scenario: "Updating with multi-megabyte transcript (memory stress test)"
    mocks:
      - target: "datetime.utcnow"
        return_value: "datetime(2024, 1, 15, 10, 30, 0)"
    expected_behavior:
      - "Large text is stored without truncation"
      - "transcribed_at is set correctly"
      - "No memory errors or limits hit"

  - function_to_test: "Recording.update_transcript"
    description: "Tests transcript update with special characters"
    scenario: "Transcript containing null bytes, Unicode, control characters"
    mocks:
      - target: "datetime.utcnow"
        return_value: "datetime(2024, 1, 15, 10, 30, 0)"
    expected_behavior:
      - "Special characters are preserved exactly"
      - "No encoding errors or data corruption"
      - "transcribed_at timestamp is set"

  - function_to_test: "Recording.update_processed_text"
    description: "Tests processed text update when raw transcript is None"
    scenario: "Processing before transcription (unusual workflow)"
    mocks:
      - target: "datetime.utcnow"
        return_value: "datetime(2024, 1, 15, 10, 30, 0)"
    expected_behavior:
      - "processed_text is set despite null raw_transcript"
      - "processed_at timestamp is set"
      - "No requirement for transcription before processing"

  # Status Logic Edge Cases
  - function_to_test: "Recording.get_status"
    description: "Tests status with whitespace-only transcripts"
    scenario: "raw_transcript is '   ' and processed_text is '\n\t'"
    mocks: []
    expected_behavior:
      - "Returns 'completed' (bool('   ') is True)"
      - "Whitespace is considered valid content"
      - "Status based on truthiness, not content validity"

  - function_to_test: "Recording.is_transcribed"
    description: "Tests transcription check with empty vs None"
    scenario: "Comparing empty string '' vs None for transcript"
    mocks: []
    expected_behavior:
      - "Empty string returns False (bool('') is False)"
      - "None returns False (bool(None) is False)"
      - "Only non-empty strings return True"

  # Database Serialization Edge Cases
  - function_to_test: "Recording.to_database_tuple"
    description: "Tests serialization with all None optional fields"
    scenario: "Recording with only required fields set"
    mocks: []
    expected_behavior:
      - "Returns 10-element tuple"
      - "Optional fields are None in correct positions"
      - "Order matches database schema exactly"

  - function_to_test: "Recording.to_database_tuple"
    description: "Tests serialization with special characters in fields"
    scenario: "Fields containing quotes, backslashes, newlines"
    mocks: []
    expected_behavior:
      - "Special characters preserved without escaping"
      - "Tuple contains raw string values"
      - "No SQL injection prevention at this layer"

  - function_to_test: "Recording.from_database_row"
    description: "Tests deserialization with wrong tuple length"
    scenario: "Database row with 9 or 11 elements instead of 10"
    mocks: []
    expected_behavior:
      - "IndexError raised for missing elements"
      - "TypeError for excess elements if unpacking"
      - "No silent data corruption"

  - function_to_test: "Recording.from_database_row"
    description: "Tests deserialization with wrong types"
    scenario: "String ID instead of int, or int instead of string filename"
    mocks: []
    expected_behavior:
      - "No type conversion or validation"
      - "Recording created with whatever types provided"
      - "Type errors surface later during usage"

  - function_to_test: "Recording.from_database_row"
    description: "Tests deserialization with None in required fields"
    scenario: "Database row has None for id, filename, or other required fields"
    mocks: []
    expected_behavior:
      - "Recording created with None values"
      - "No validation during deserialization"
      - "Invalid state allowed but may fail on use"

  # Dataclass Behavior Edge Cases
  - function_to_test: "Recording.__init__"
    description: "Tests initialization with mixed positional and keyword args"
    scenario: "Calling Recording with some positional, some keyword arguments"
    mocks: []
    expected_behavior:
      - "Dataclass handles argument mixing correctly"
      - "No duplicate argument errors"
      - "Arguments map to correct fields"

  - function_to_test: "Recording.__eq__"
    description: "Tests equality with different optional field combinations"
    scenario: "Two recordings with same required fields but different optional fields"
    mocks: []
    expected_behavior:
      - "Equality based on all fields (dataclass default)"
      - "Different transcripts make recordings unequal"
      - "None vs empty string are not equal"

  - function_to_test: "Recording.__hash__"
    description: "Tests hashability for use in sets/dicts"
    scenario: "Recording used as dictionary key or in set"
    mocks: []
    expected_behavior:
      - "TypeError raised (dataclass with mutable fields)"
      - "Recording is not hashable by default"
      - "Cannot be used as dict key without frozen=True"