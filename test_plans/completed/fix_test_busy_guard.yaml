target_file: "app/ui_utils/busy_guard.py"
test_file: "app/tests/test_busy_guard.py"
dependencies_to_mock:
  - "logging.getLogger"
  - "uuid.uuid4"
  - "PyQt6.QtWidgets.QWidget"

test_cases:
  # Basic Context Manager Behavior
  - function_to_test: "BusyGuard.__enter__"
    description: "Guard starts and coordinates UI feedback correctly"
    scenario: "When entering context, guard disables UI and starts visual feedback"
    mocks:
      - target: "feedback_manager"
        return_value: "mock with set_ui_busy, start_spinner, show_status methods"
    expected_behavior:
      - "UI elements are disabled via set_ui_busy(True, elements)"
      - "Spinner starts if name provided"
      - "Status message displays if provided"
      - "Returns self for fluent usage"

  - function_to_test: "BusyGuard.__exit__"
    description: "Guard cleans up all resources on normal exit"
    scenario: "When exiting context normally, all UI feedback stops"
    mocks:
      - target: "feedback_manager"
        return_value: "mock tracking stop_spinner, finish_progress calls"
    expected_behavior:
      - "Spinner stops if it was started"
      - "Progress completes with success message"
      - "UI re-enabled via finish_operation if supported"
      - "Returns False to not suppress exceptions"

  # Error Path - Setup Failures
  - function_to_test: "BusyGuard.__enter__"
    description: "Partial setup failure triggers cleanup"
    scenario: "When start_progress raises exception during setup"
    mocks:
      - target: "feedback_manager.start_progress"
        side_effect: "raises RuntimeError('progress failed')"
    expected_behavior:
      - "Exception propagates to caller"
      - "__exit__ called to clean up partial state"
      - "Spinner stopped if it was started"
      - "UI elements re-enabled"

  - function_to_test: "BusyGuard.__enter__"
    description: "Missing spinner handled gracefully"
    scenario: "When spinner name invalid, operation continues"
    mocks:
      - target: "feedback_manager.start_spinner"
        return_value: "False"
      - target: "logger.warning"
        return_value: "mock logger"
    expected_behavior:
      - "Warning logged about missing spinner"
      - "Operation continues without spinner"
      - "Other UI feedback still works"
      - "Context manager enters successfully"

  - function_to_test: "BusyGuard.__enter__"
    description: "Status message error doesn't fail operation"
    scenario: "When show_status raises exception"
    mocks:
      - target: "feedback_manager.show_status"
        side_effect: "raises RuntimeError('status broken')"
      - target: "logger.error"
        return_value: "mock logger"
    expected_behavior:
      - "Error logged with traceback"
      - "Setup continues despite status error"
      - "Context manager enters successfully"
      - "Other feedback mechanisms work"

  # Error Path - Cleanup Failures
  - function_to_test: "BusyGuard.__exit__"
    description: "Cleanup errors don't mask original exception"
    scenario: "When stop_spinner fails during exception cleanup"
    mocks:
      - target: "feedback_manager.stop_spinner"
        side_effect: "raises RuntimeError('stop failed')"
      - target: "logger.error"
        return_value: "mock logger"
    expected_behavior:
      - "Original ValueError propagates to caller"
      - "Cleanup error logged but not raised"
      - "Remaining cleanup attempted"
      - "UI state eventually restored"

  - function_to_test: "BusyGuard.__exit__"
    description: "Exception during operation triggers proper cleanup"
    scenario: "When user code raises exception within context"
    mocks:
      - target: "feedback_manager"
        return_value: "mock tracking close_progress, stop_spinner"
    expected_behavior:
      - "Progress closed (not finished) on exception"
      - "Spinner stopped"
      - "Exception info passed to __exit__"
      - "User exception propagates"

  # Progress Management
  - function_to_test: "BusyGuard.update_progress"
    description: "Progress updates only when dialog active"
    scenario: "Calling update_progress with active progress dialog"
    mocks:
      - target: "feedback_manager.update_progress"
        return_value: "None"
    expected_behavior:
      - "update_progress called on feedback_manager"
      - "Operation ID, value, and message passed through"
      - "No action if progress_started is False"

  - function_to_test: "BusyGuard.__enter__"
    description: "Indeterminate progress with maximum=0"
    scenario: "Creating progress dialog with progress_maximum=0"
    mocks:
      - target: "feedback_manager.start_progress"
        return_value: "None"
    expected_behavior:
      - "Progress starts with maximum=0"
      - "Dialog shows indeterminate progress"
      - "Updates still possible but show activity only"

  # Cancellation Handling
  - function_to_test: "BusyGuard.cancel"
    description: "Cancel invokes callback once"
    scenario: "Calling cancel with callback provided"
    mocks:
      - target: "cancel_callback"
        return_value: "None"
    expected_behavior:
      - "Callback invoked exactly once"
      - "Progress dialog closed immediately"
      - "Status shows cancellation message"
      - "Multiple cancel calls don't re-invoke callback"

  - function_to_test: "BusyGuard.cancel"
    description: "Cancel callback exception handled"
    scenario: "When cancel callback raises exception"
    mocks:
      - target: "cancel_callback"
        side_effect: "raises ValueError('cancel failed')"
      - target: "logger.error"
        return_value: "mock logger"
    expected_behavior:
      - "Exception logged with traceback"
      - "Progress still closed"
      - "Status still shows cancellation"
      - "Guard remains usable"

  - function_to_test: "BusyGuard.cancel"
    description: "Cancel without callback works"
    scenario: "Calling cancel when no callback provided"
    mocks:
      - target: "feedback_manager"
        return_value: "mock with close_progress, show_status"
    expected_behavior:
      - "No exceptions raised"
      - "Progress closed if active"
      - "Cancellation status displayed"

  # Result Capture
  - function_to_test: "BusyGuard.set_result"
    description: "Result stored and returned fluently"
    scenario: "Setting result during operation"
    mocks: []
    expected_behavior:
      - "Result stored in self.result"
      - "Same value returned for chaining"
      - "Result accessible after context exit"
      - "Works with any type T"

  # Operation Tracking
  - function_to_test: "BusyGuard.__enter__"
    description: "Optional operation tracking via start_operation"
    scenario: "When feedback_manager has start_operation method"
    mocks:
      - target: "feedback_manager.start_operation"
        return_value: "None"
    expected_behavior:
      - "start_operation called with operation_id"
      - "_started_operation flag set"
      - "Non-fatal if method missing"
      - "Debug message if unavailable"

  - function_to_test: "BusyGuard.__exit__"
    description: "Operation finish called if started"
    scenario: "When operation was tracked via start_operation"
    mocks:
      - target: "feedback_manager.finish_operation"
        return_value: "None"
    expected_behavior:
      - "finish_operation called with operation_id"
      - "Only called if _started_operation is True"
      - "Errors logged but not raised"
      - "UI state restoration attempted"

  # Resource Cleanup Edge Cases
  - function_to_test: "BusyGuard.__exit__"
    description: "No cleanup attempted for unstarted components"
    scenario: "When spinner/progress never started"
    mocks:
      - target: "feedback_manager"
        return_value: "mock tracking method calls"
    expected_behavior:
      - "stop_spinner not called if spinner_started=False"
      - "close_progress not called if progress_started=False"
      - "Avoids unnecessary cleanup calls"

  - function_to_test: "BusyGuard.__init__"
    description: "Unique operation IDs generated"
    scenario: "Creating multiple BusyGuard instances"
    mocks:
      - target: "uuid.uuid4"
        return_value: "mock returning different hex values"
    expected_behavior:
      - "Each instance gets unique operation_id"
      - "ID includes operation name (lowercased, underscored)"
      - "ID includes UUID hex suffix"
      - "IDs trackable across feedback operations"

  # UI Element Management
  - function_to_test: "BusyGuard.__enter__"
    description: "Empty UI elements list handled correctly"
    scenario: "When ui_elements is empty list or None"
    mocks:
      - target: "feedback_manager.set_ui_busy"
        return_value: "None"
    expected_behavior:
      - "set_ui_busy not called for empty list"
      - "ui_busy flag remains False"
      - "Other feedback mechanisms still work"

  - function_to_test: "BusyGuard.__enter__"
    description: "Multiple UI elements disabled together"
    scenario: "When multiple widgets provided in ui_elements"
    mocks:
      - target: "feedback_manager.set_ui_busy"
        return_value: "None"
    expected_behavior:
      - "All elements passed to set_ui_busy"
      - "Elements disabled as a group"
      - "ui_busy flag set to True"

  # Abnormal Termination
  - function_to_test: "BusyGuard.__exit__"
    description: "Handles KeyboardInterrupt during operation"
    scenario: "When KeyboardInterrupt occurs in user code"
    mocks:
      - target: "feedback_manager"
        return_value: "mock tracking cleanup calls"
    expected_behavior:
      - "All resources cleaned up"
      - "Progress closed not finished"
      - "KeyboardInterrupt propagates"
      - "UI state restored"

  - function_to_test: "BusyGuard.__exit__"
    description: "Handles SystemExit during operation"
    scenario: "When sys.exit() called in user code"
    mocks:
      - target: "feedback_manager"
        return_value: "mock tracking cleanup calls"
    expected_behavior:
      - "Cleanup attempted before exit"
      - "SystemExit propagates"
      - "Resources released"

  # Progress Dialog Configuration
  - function_to_test: "BusyGuard.__init__"
    description: "Default progress messages generated from operation name"
    scenario: "When progress enabled without custom messages"
    mocks: []
    expected_behavior:
      - "progress_title defaults to operation_name"
      - "progress_message includes lowercased operation_name"
      - "status_message includes lowercased operation_name"
      - "Messages are grammatically correct"

  - function_to_test: "BusyGuard.__enter__"
    description: "Progress cancelable flag respected"
    scenario: "When progress_cancelable=False"
    mocks:
      - target: "feedback_manager.start_progress"
        return_value: "None"
    expected_behavior:
      - "cancelable=False passed to start_progress"
      - "Dialog cannot be cancelled by user"
      - "cancel_callback not used"

  # Thread Safety Considerations
  - function_to_test: "BusyGuard.cancel"
    description: "Cancel idempotency prevents double callback"
    scenario: "When cancel called multiple times rapidly"
    mocks:
      - target: "cancel_callback"
        return_value: "None"
    expected_behavior:
      - "Callback invoked exactly once"
      - "_cancel_invoked flag prevents re-entry"
      - "Multiple close_progress calls safe"
      - "Status message shown each time"

  # Integration Points
  - function_to_test: "BusyGuard.__enter__"
    description: "All feedback mechanisms work together"
    scenario: "When all features enabled simultaneously"
    mocks:
      - target: "feedback_manager"
        return_value: "full mock implementation"
    expected_behavior:
      - "UI disabled, spinner started, progress shown, status displayed"
      - "Operation tracked if supported"
      - "All in correct order"
      - "No interference between mechanisms"

  - function_to_test: "BusyGuard.__exit__"
    description: "Complete cleanup even with all features active"
    scenario: "When exiting with all feedback active"
    mocks:
      - target: "feedback_manager"
        return_value: "mock tracking all cleanup"
    expected_behavior:
      - "Spinner stopped, progress finished, operation finished"
      - "Cleanup in reverse order of setup"
      - "UI state fully restored"
      - "No leaked resources"