target_file: "/home/john/transcribrr/app/ui_utils/__init__.py"
test_file: "/home/john/transcribrr/app/tests/test_spinner_no_gui.py"
current_issues:
  - weak_coverage: "Tests only happy path scenarios with minimal edge cases"
  - unclear_intent: "Test names don't clearly describe behavior being tested"
  - excessive_mocking: "Uses object() placeholders instead of meaningful test doubles"
  - missing_scenarios: "No error handling, race conditions, or state corruption tests"
  - shallow_assertions: "Tests check boolean returns but not actual state changes"
  - no_integration: "Tests don't validate interaction between SpinnerManager and FeedbackManager"

improvement_plan:
  phase_1_refactoring:
    - action: "Rename test file to test_ui_feedback_headless.py"
      reason: "Better reflects the headless nature and broader scope"
    
    - action: "Split into focused test classes"
      new_structure:
        - "TestSpinnerManagerCore: Basic spinner lifecycle and state management"
        - "TestSpinnerManagerErrorHandling: Error scenarios and edge cases"
        - "TestFeedbackManagerCore: Basic feedback operations"
        - "TestFeedbackManagerIntegration: Integration with SpinnerManager"
        - "TestFeedbackManagerConcurrency: Concurrent operation handling"
    
    - action: "Create meaningful test doubles"
      implementations:
        - name: "FakeToolbar"
          purpose: "Simulate toolbar behavior for spinner attachment"
          attributes:
            - "actions: List of attached actions"
            - "visible: Boolean visibility state"
        
        - name: "FakeUIElement"
          purpose: "Simulate UI elements for enable/disable tracking"
          attributes:
            - "enabled: Boolean enabled state"
            - "enable_history: List of state changes"
        
        - name: "CallbackTracker"
          purpose: "Track callback invocations"
          attributes:
            - "call_count: Number of invocations"
            - "call_args: Arguments from each call"

  phase_2_new_test_cases:
    spinner_manager_tests:
      - test_name: "test_create_spinner_validates_parameters"
        scenario: "Creating spinner with None or invalid parameters"
        expected: "Graceful handling, no crashes, appropriate defaults"
      
      - test_name: "test_spinner_state_persistence_across_operations"
        scenario: "Multiple toggle operations maintain consistent state"
        expected: "State remains synchronized, no state corruption"
      
      - test_name: "test_concurrent_spinner_operations"
        scenario: "Multiple spinners activated/deactivated simultaneously"
        expected: "Each spinner maintains independent state"
      
      - test_name: "test_spinner_cleanup_on_stop_all"
        scenario: "stop_all_spinners called with various spinner states"
        expected: "All spinners properly stopped, state cleared"
      
      - test_name: "test_duplicate_spinner_creation"
        scenario: "Attempting to create spinner with existing name"
        expected: "Either replaces or rejects based on design"
      
      - test_name: "test_spinner_memory_leak_prevention"
        scenario: "Creating and destroying many spinners"
        expected: "No accumulation of stale spinner references"

    feedback_manager_tests:
      - test_name: "test_operation_tracking_with_nested_operations"
        scenario: "Starting operations within other operations"
        expected: "Proper tracking, UI only re-enabled when all complete"
      
      - test_name: "test_ui_state_restoration_after_crash"
        scenario: "Exception during operation completion"
        expected: "UI state properly restored, no stuck disabled elements"
      
      - test_name: "test_progress_dialog_lifecycle"
        scenario: "Full progress dialog create/update/close cycle"
        expected: "Proper resource management, no orphaned dialogs"
      
      - test_name: "test_mixed_feedback_types"
        scenario: "Spinner and progress active simultaneously"
        expected: "Both tracked independently, proper cleanup"
      
      - test_name: "test_stop_all_feedback_comprehensive"
        scenario: "Multiple active spinners, progress dialogs, UI states"
        expected: "Everything properly cleaned up and restored"
      
      - test_name: "test_ui_element_tracking_with_invalid_elements"
        scenario: "Tracking elements that throw exceptions on access"
        expected: "Graceful handling, no crashes, partial restoration"
      
      - test_name: "test_operation_id_collision"
        scenario: "Same operation_id used for different operations"
        expected: "Proper handling or rejection based on design"

  phase_3_test_patterns:
    - pattern: "Arrange-Act-Assert with clear sections"
      example: |
        def test_spinner_state_persistence(self):
            # Arrange
            manager = SpinnerManager()
            fake_toolbar = FakeToolbar()
            callback = CallbackTracker()
            
            # Act
            manager.create_spinner("test", fake_toolbar, None, "tip", callback)
            initial_state = manager.is_active("test")
            manager.toggle_spinner("test")
            after_first_toggle = manager.is_active("test")
            manager.toggle_spinner("test")
            final_state = manager.is_active("test")
            
            # Assert
            self.assertFalse(initial_state, "Spinner should start inactive")
            self.assertTrue(after_first_toggle, "First toggle should activate")
            self.assertFalse(final_state, "Second toggle should deactivate")
            self.assertEqual(callback.call_count, 0, "Callback not invoked in headless mode")
    
    - pattern: "Descriptive test names with Given-When-Then"
      example: |
        def test_given_active_spinner_when_stop_all_called_then_spinner_deactivated(self):
            # Implementation follows name structure
    
    - pattern: "Error scenario testing with context managers"
      example: |
        def test_exception_during_ui_restoration(self):
            # Arrange
            manager = FeedbackManager()
            broken_element = FakeUIElement(raise_on_enable=True)
            working_element = FakeUIElement()
            
            # Act & Assert
            manager.set_ui_busy(True, [broken_element, working_element])
            manager.finish_operation("test")  # Should not crash
            
            # Verify partial restoration
            self.assertTrue(working_element.enabled)
            self.assertEqual(len(manager.ui_state), 0, "State cleared despite error")

  phase_4_coverage_targets:
    - metric: "Line coverage"
      target: "95% for headless implementations"
      current: "~60% (estimated)"
    
    - metric: "Branch coverage"
      target: "90% for all conditional paths"
      current: "~40% (estimated)"
    
    - metric: "Error path coverage"
      target: "100% of exception handlers tested"
      current: "0% (no error tests)"
    
    - metric: "State transition coverage"
      target: "All valid state transitions tested"
      current: "Basic transitions only"

  phase_5_documentation:
    - action: "Add comprehensive docstrings"
      format: |
        """Test that [specific behavior] when [condition].
        
        This test verifies that the [component] correctly [action]
        when [scenario]. This is important because [rationale].
        
        Test coverage:
        - [Path 1]: [Description]
        - [Path 2]: [Description]
        """
    
    - action: "Add test data builders"
      example: |
        class TestDataBuilder:
            @staticmethod
            def create_configured_spinner_manager(**overrides):
                manager = SpinnerManager()
                defaults = {
                    "spinner1": {"toolbar": FakeToolbar(), "active": False},
                    "spinner2": {"toolbar": FakeToolbar(), "active": True}
                }
                for name, config in defaults.items():
                    if name not in overrides.get("exclude", []):
                        manager.create_spinner(name, config["toolbar"], ...)
                        if config["active"]:
                            manager.toggle_spinner(name)
                return manager

  implementation_checklist:
    week_1:
      - "Create new test file structure with focused test classes"
      - "Implement FakeToolbar, FakeUIElement, CallbackTracker"
      - "Write comprehensive SpinnerManager tests"
      - "Achieve 90% coverage for SpinnerManager"
    
    week_2:
      - "Write comprehensive FeedbackManager tests"
      - "Add error scenario tests for both managers"
      - "Implement concurrent operation tests"
      - "Achieve 90% coverage for FeedbackManager"
    
    week_3:
      - "Add integration tests between components"
      - "Implement state transition tests"
      - "Add performance/memory leak tests"
      - "Document all test scenarios"

  success_metrics:
    - "Test file score improves from 4/10 to 8+/10"
    - "All error paths have explicit test coverage"
    - "Test execution time remains under 1 second"
    - "Zero use of object() placeholders"
    - "Clear test intent from method names alone"
    - "Comprehensive assertions verifying all state changes"
    - "No reliance on implementation details"
    - "Tests serve as executable documentation"

  anti_patterns_to_avoid:
    - "Using object() as mock objects"
    - "Testing only happy paths"
    - "Unclear test names like 'test_spinner_lifecycle'"
    - "Missing assertions on side effects"
    - "Not testing error recovery"
    - "Ignoring concurrent operation scenarios"
    - "Testing implementation rather than behavior"
    - "Monolithic test methods doing too much"

  example_improved_test:
    before: |
      def test_spinner_lifecycle(self):
          sm = SpinnerManager(None)
          sm.create_spinner("s1", toolbar=object(), action_icon=None, 
                           action_tooltip="t", callback=lambda: None)
          self.assertFalse(sm.is_active("s1"))
          self.assertTrue(sm.toggle_spinner("s1"))
          self.assertTrue(sm.is_active("s1"))
    
    after: |
      def test_newly_created_spinner_starts_inactive_and_toggles_correctly(self):
          """Verify spinner lifecycle: creation, activation, and deactivation.
          
          Tests that a newly created spinner:
          1. Starts in inactive state
          2. Becomes active on first toggle
          3. Returns to inactive on second toggle
          4. Maintains state consistency throughout
          """
          # Arrange
          manager = SpinnerManager()
          fake_toolbar = FakeToolbar()
          callback_tracker = CallbackTracker()
          spinner_name = "test_spinner"
          
          # Act - Create spinner
          created_action = manager.create_spinner(
              name=spinner_name,
              toolbar=fake_toolbar,
              action_icon=None,  # Headless mode
              action_tooltip="Test spinner tooltip",
              callback=callback_tracker.track
          )
          
          # Assert - Initial state
          self.assertIsNotNone(created_action, "Spinner creation should return action object")
          self.assertIn(spinner_name, manager.spinners, "Spinner should be registered")
          self.assertFalse(manager.is_active(spinner_name), "New spinner should be inactive")
          
          # Act - First toggle (activate)
          activation_result = manager.toggle_spinner(spinner_name)
          
          # Assert - Active state
          self.assertTrue(activation_result, "Toggle should return True when activating")
          self.assertTrue(manager.is_active(spinner_name), "Spinner should be active after toggle")
          self.assertEqual(manager.spinners[spinner_name]["active"], True, 
                          "Internal state should reflect activation")
          
          # Act - Second toggle (deactivate)
          deactivation_result = manager.toggle_spinner(spinner_name)
          
          # Assert - Inactive state
          self.assertFalse(deactivation_result, "Toggle should return False when deactivating")
          self.assertFalse(manager.is_active(spinner_name), "Spinner should be inactive after second toggle")
          self.assertEqual(manager.spinners[spinner_name]["active"], False,
                          "Internal state should reflect deactivation")
          
          # Verify callback was not invoked in headless mode
          self.assertEqual(callback_tracker.call_count, 0, 
                          "Callbacks should not execute in headless mode")